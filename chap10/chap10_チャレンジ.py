#　Q1 p138のコードを書き換えて、答えの単語をリストからランダムに選ぶようにする


def hangman(word):
    wrong = 0
    stages = ["",
              "_________        ",
              "|                ",
              "|        |       ",
              "|        O       ",
              "|       /|\      ",
              "|       / \      ",
              "|                "
              ]
    rletters = list(word)
    board = ["_"] * len(word)
    win = False
    print("ハングマンにようこそ！")
    #print(board)
    """
    hangman(word)のwordという引数は当ててほしい言葉を入れる引数

    wrong はプレイヤーが何回間違えたかをカウントする変数、初期値は０に設定している

    変数stages は文字列のリストを使って、吊られている人の絵を表現している。この８つの要素が全て出力されたらプレイヤーの負け
    変数rletters は答えの言葉を、一つ一つの要素にリストにしたもの。
    変数boardは文字列のリストで、プレイヤーに見せるヒントに使う、例えば答えの言葉が"cat"でプレイヤーが"c"と"t"を当てたら、"c_t"と表現する為に使う。
    その式の["_"] * len(word)は答えの言葉が"cat"なら初期の表示は,["_","_","_"]になる。
    変数win はこのゲームの勝敗を記録する場所。初期状態はFalseに設定
    そして最後に "ハングマンにようこそと表示する"
    """

    while wrong < len(stages) - 1:
        print("\n")
        msg = "1文字を予想してね"
        char = input(msg)
        if char in rletters:                 #１文字ずつの答えの単語のリストと　msg = "1文字を予想してね"　で入れさせた１文字のデータをin演算子で評価している。１文字に単位を揃えているから整合性があるのか。。。
            cind = rletters.index(char)      #試しに１文字以上の答えをインプットに入れたらin演算子でTrueにならないため合っていてもwrongのカウントが上がった！１文字で評価しているのが肝になっている・
            board[cind] = char
            rletters[cind] = "$"
        else:
            wrong += 1
        print(" ".join(board))
        e = wrong + 1
        print("\n".join(stages[0:e]))
        if "_" not in board:
            print("あなたの勝ち！")
            print(" ".join(board))
            win = True
            break
        """
        while wrong < len(stages) - 1:  の意味は、wrongは間違えた数をカウントしている変数で、
                                        len(stages) - 1 はハングマンが全て表示（ゲームオーバーになる）一つ前までの状態を表している。
                                        つまり、このwhileループは、ゲームオーバーになる一つ前の状態まで、Trueとなりループする。
        print("\n")                     の意味は”ハングマンにようこそ”と”１文字を予想してね”の隙間を表現している、ただのデザインでプログラムを起動した時の見栄えのためにある。
        char = input(msg)               の意味は、インプットさせたデータを char に格納している。
        if char in rletters:            このif文の意味は、rletters(正解の単語を細切れに１文字ずつリストの中に入れてある変数)の中にchar(１文字入力してくれと言ったデータ)が入っているか
                                        in演算子で評価している。Trueなら下のブロックへ、Falseならelseのブロックの処理に移る。
        cind = rletters.index(char)     if文をTrueしてきたcharつまり正解に含まれている単語のcharのインデックスの値を正解データのrlettersから検索して、cindという変数に格納している。
        board[cind] = char              ここで正解のインデックス値のboard("c_t"みたいな＿でヒントを表現している変数)にchar(正解の１文字)を代入して、上書きしていることになる。
        rletters[cind] = "$"            この解説は本、chatGPTを活用してがよく分からない。本の解説ページはp137
                                        多分この文がないと同じ文字を含んだ言葉が答えの時、例えば”aaabb"の時に、正解の"a"を入れてもindex演算子を使って検索してくるのは最初にヒットしたインデックスなので
                                        永遠と最初の"a"だと判断してしまうのだと思う。正解したインデックスはそこにあった正解の文字を"$"に置き換えて次"a"と回答されたら、本当は2個目の"a"を一つ目の
                                        としてインデックス検索に引っかけるようにしているのだと思う。
        else:                           if文の判定がFalseならこっちのブロックに流れてくる
            wrong += 1                  if char in rletters: がFalse、つまりインプットした1文字が不正解なら、wrong(何回間違えたかをカウントする変数)にプラス1をする
        print(" ".join(board))          変数boardは、"_"*答えの文字数 なっているから、たとえは答えが３文字なら['_', '_', '_']このようなリストになる。
                                        この3つの要素をjoinメソッドで半角スペースを挟んで繋げている。よって、['_', '_', '_']このリストが _ _ _という文字列になりprintされて表記される。
        e = wrong + 1                   変数e は、この後のハングマンを描画する範囲に使う。wrongにプラス1をしているのはスライスでリストのデータを切り取った時、ゲームに合わせた状態を描画する為。
        print("\n".join(stages[0:e]))   この行では、stages(ハングマンの絵のリスト)をprintしている、"\n".join で繋げる時に改行を挟んでいる。   
                                        stages[0:e]の[0:e]の部分はstagesのリストからスライスしてデータを切り取っている、切り取る開始位置は0、つまり最初のインデックス値で、終わり位置は
                                        さっき作った変数e、なぜ +1 しているかというと、スライスは指定したインデックス値の前で切り抜くからwrongの状態にリンクした絵の状態を切り抜かせるため。
        if "_" not in board:            このif文は,もし boardの中に "_" が無くなったらTrue つまりboardの _ が全て正解の文字に置き換えられたら、発動する式となる。
            print("あなたの勝ち！")       上のif文がTrueならあなたの勝ちと表示する。
            print(" ".join(board))      ここまで通ってきたboradは "_" が正解の文字に全て置き換わっているのでそれを,半角スペースを入れて連結して表示する。正解の文字はコレですよと見せる感じ。
            win = True                  勝敗判定で使う変数winを Trueに変更。 勝敗判定は、負け判定の時に使う、ここでは誤作動しないようにTrueに変更している。
            break                       ブレイクし、ループを抜ける。
        """

    if not win:
        print("\n".join(stages[0:wrong+1]))
        print("あなたの負け！正解は{}.".format(word))
    
    """
    if not win:                                  もしwinがFalseならこのif文はTrueとなりこのブロックの処理が実行される。 not win の意味は、winがFalse なら Trueを返す
      print("\n".join(stages[0:wrong+1]))        stages(ハングマンの絵のリスト)をprintしている、"\n".join で繋げる時に改行を挟んでいる。 
                                                 [0:wrong+1]はスライスでデータを切り取っている、開始位置は0で、終わり位置はwrong(プレイヤーが何回間違えたかをカウントする変数) +1のところ
                                                 なぜ＋１足しているかというと、スレイスは指定したインデックスの一つ前で切り抜きをするから。(一つ上のブロックにほぼ同じことをしているコードがある→print("\n".join(stages[0:e])) )
      print("あなたの負け！正解は{}.".format(word))  正解していたら、上のブロックでwin=Trueになり、このブロックの処理はスキップされるのでこの行のコードが動いているということは
                                                  while wrong < len(stages) - 1:このループの条件がFalseになり(間違えカウント変数の数が、ハングマンの絵の要素数を上回りループを抜けたパターン)
                                                  負け通知を言い渡されることになる、そのためprintでその通告を受け、正解はformatメソッドを使い正解の"word"を埋め込んでいる(f文字列で同じことができ、そっちのが簡素で良い)                                        
    
    """



import random

data_list = ["ねこ","いぬ","ごりら","らいおん","うさぎ"]
answer = random.choice(data_list)
hangman(f"{answer}")
